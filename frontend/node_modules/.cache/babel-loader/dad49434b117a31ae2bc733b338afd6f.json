{"ast":null,"code":"const localList = require('./lang.json').words;\n\nconst baseList = require('badwords-list').array;\n\nclass Filter {\n  /**\n   * Filter constructor.\n   * @constructor\n   * @param {object} options - Filter instance options\n   * @param {boolean} options.emptyList - Instantiate filter with no blacklist\n   * @param {array} options.list - Instantiate filter with custom list\n   * @param {string} options.placeHolder - Character used to replace profane words.\n   * @param {string} options.regex - Regular expression used to sanitize words before comparing them to blacklist.\n   * @param {string} options.replaceRegex - Regular expression used to replace profane words with placeHolder.\n   * @param {string} options.splitRegex - Regular expression used to split a string into words.\n   */\n  constructor(options = {}) {\n    Object.assign(this, {\n      list: options.emptyList && [] || Array.prototype.concat.apply(localList, [baseList, options.list || []]),\n      exclude: options.exclude || [],\n      splitRegex: options.splitRegex || /\\b/,\n      placeHolder: options.placeHolder || '*',\n      regex: options.regex || /[^a-zA-Z0-9|\\$|\\@]|\\^/g,\n      replaceRegex: options.replaceRegex || /\\w/g\n    });\n  }\n  /**\n   * Determine if a string contains profane language.\n   * @param {string} string - String to evaluate for profanity.\n   */\n\n\n  isProfane(string) {\n    return this.list.filter(word => {\n      const wordExp = new RegExp(`\\\\b${word.replace(/(\\W)/g, '\\\\$1')}\\\\b`, 'gi');\n      return !this.exclude.includes(word.toLowerCase()) && wordExp.test(string);\n    }).length > 0 || false;\n  }\n  /**\n   * Replace a word with placeHolder characters;\n   * @param {string} string - String to replace.\n   */\n\n\n  replaceWord(string) {\n    return string.replace(this.regex, '').replace(this.replaceRegex, this.placeHolder);\n  }\n  /**\n   * Evaluate a string for profanity and return an edited version.\n   * @param {string} string - Sentence to filter.\n   */\n\n\n  clean(string) {\n    return string.split(this.splitRegex).map(word => {\n      return this.isProfane(word) ? this.replaceWord(word) : word;\n    }).join(this.splitRegex.exec(string)[0]);\n  }\n  /**\n   * Add word(s) to blacklist filter / remove words from whitelist filter\n   * @param {...string} word - Word(s) to add to blacklist\n   */\n\n\n  addWords() {\n    let words = Array.from(arguments);\n    this.list.push(...words);\n    words.map(word => word.toLowerCase()).forEach(word => {\n      if (this.exclude.includes(word)) {\n        this.exclude.splice(this.exclude.indexOf(word), 1);\n      }\n    });\n  }\n  /**\n   * Add words to whitelist filter\n   * @param {...string} word - Word(s) to add to whitelist.\n   */\n\n\n  removeWords() {\n    this.exclude.push(...Array.from(arguments).map(word => word.toLowerCase()));\n  }\n\n}\n\nmodule.exports = Filter;","map":{"version":3,"sources":["C:/Users/andib/Desktop/QAC-TE/QAC-TE/frontend/node_modules/bad-words/lib/badwords.js"],"names":["localList","require","words","baseList","array","Filter","constructor","options","Object","assign","list","emptyList","Array","prototype","concat","apply","exclude","splitRegex","placeHolder","regex","replaceRegex","isProfane","string","filter","word","wordExp","RegExp","replace","includes","toLowerCase","test","length","replaceWord","clean","split","map","join","exec","addWords","from","arguments","push","forEach","splice","indexOf","removeWords","module","exports"],"mappings":"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","sourcesContent":["const localList = require('./lang.json').words;\nconst baseList = require('badwords-list').array;\n\nclass Filter {\n\n  /**\n   * Filter constructor.\n   * @constructor\n   * @param {object} options - Filter instance options\n   * @param {boolean} options.emptyList - Instantiate filter with no blacklist\n   * @param {array} options.list - Instantiate filter with custom list\n   * @param {string} options.placeHolder - Character used to replace profane words.\n   * @param {string} options.regex - Regular expression used to sanitize words before comparing them to blacklist.\n   * @param {string} options.replaceRegex - Regular expression used to replace profane words with placeHolder.\n   * @param {string} options.splitRegex - Regular expression used to split a string into words.\n   */\n  constructor(options = {}) {\n    Object.assign(this, {\n      list: options.emptyList && [] || Array.prototype.concat.apply(localList, [baseList, options.list || []]),\n      exclude: options.exclude || [],\n      splitRegex: options.splitRegex || /\\b/,\n      placeHolder: options.placeHolder || '*',\n      regex: options.regex || /[^a-zA-Z0-9|\\$|\\@]|\\^/g,\n      replaceRegex: options.replaceRegex || /\\w/g\n    })\n  }\n\n  /**\n   * Determine if a string contains profane language.\n   * @param {string} string - String to evaluate for profanity.\n   */\n  isProfane(string) {\n    return this.list\n      .filter((word) => {\n        const wordExp = new RegExp(`\\\\b${word.replace(/(\\W)/g, '\\\\$1')}\\\\b`, 'gi');\n        return !this.exclude.includes(word.toLowerCase()) && wordExp.test(string);\n      })\n      .length > 0 || false;\n  }\n\n  /**\n   * Replace a word with placeHolder characters;\n   * @param {string} string - String to replace.\n   */\n  replaceWord(string) {\n    return string\n      .replace(this.regex, '')\n      .replace(this.replaceRegex, this.placeHolder);\n  }\n\n  /**\n   * Evaluate a string for profanity and return an edited version.\n   * @param {string} string - Sentence to filter.\n   */\n  clean(string) {\n    return string.split(this.splitRegex).map((word) => {\n      return this.isProfane(word) ? this.replaceWord(word) : word;\n    }).join(this.splitRegex.exec(string)[0]);\n  }\n\n  /**\n   * Add word(s) to blacklist filter / remove words from whitelist filter\n   * @param {...string} word - Word(s) to add to blacklist\n   */\n  addWords() {\n    let words = Array.from(arguments);\n\n    this.list.push(...words);\n\n    words\n      .map(word => word.toLowerCase())\n      .forEach((word) => {\n        if (this.exclude.includes(word)) {\n          this.exclude.splice(this.exclude.indexOf(word), 1);\n        }\n      });\n  }\n\n  /**\n   * Add words to whitelist filter\n   * @param {...string} word - Word(s) to add to whitelist.\n   */\n  removeWords() {\n    this.exclude.push(...Array.from(arguments).map(word => word.toLowerCase()));\n  }\n}\n\nmodule.exports = Filter;"]},"metadata":{},"sourceType":"script"}