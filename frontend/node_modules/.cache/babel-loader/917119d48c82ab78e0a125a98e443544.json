{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = useObserveScrollLeft;\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/asyncToGenerator\"));\n\nvar _react = require(\"react\");\n\nvar _memoizeOne = _interopRequireDefault(require(\"memoize-one\"));\n\nvar _debounce = _interopRequireDefault(require(\"../../util/debounce\"));\n\nfunction sleepZero() {\n  return new Promise(function (resolve) {\n    return setTimeout(function () {\n      return resolve();\n    });\n  });\n}\n\nfunction useObserveScrollLeft(callbackRefWithSubscribe, observer) {\n  (0, _react.useEffect)(function () {\n    return callbackRefWithSubscribe.subscribe(function (current) {\n      if (!current) {\n        return;\n      }\n\n      var memoizedEmitValue = (0, _memoizeOne.default)(function (initial, fraction, width) {\n        return observer && observer({\n          initial: initial,\n          fraction: fraction,\n          width: width\n        });\n      });\n\n      var emitValue = function emitValue(initial) {\n        var offsetWidth = current.offsetWidth,\n            scrollLeft = current.scrollLeft,\n            scrollWidth = current.scrollWidth;\n        memoizedEmitValue(initial, \"\".concat(scrollWidth === offsetWidth ? 0 : scrollLeft / (scrollWidth - offsetWidth) * 100, \"%\"), \"\".concat(offsetWidth / scrollWidth * 100, \"%\"));\n      };\n\n      var handleScroll = function handleScroll() {\n        return emitValue(false);\n      };\n\n      var handlePointerOver = (0, _debounce.default)(function () {\n        // We need to send \"onScroll\" because \"scrollWidth\" might have changed\n        // For example, the container resized, the scroll width will be incorrect\n        // We will debounce to prevent \"pointerOver\" calculating too often\n        // We will memoize to prevent firing unnecessary \"onScroll\"\n        emitValue(false);\n      });\n      current.addEventListener('pointerover', handlePointerOver, {\n        passive: true\n      });\n      current.addEventListener('scroll', handleScroll, {\n        passive: true\n      });\n      (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee() {\n        return _regenerator.default.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!(current.scrollWidth === current.offsetWidth)) {\n                  _context.next = 3;\n                  break;\n                }\n\n                _context.next = 3;\n                return sleepZero();\n\n              case 3:\n                emitValue(true);\n\n              case 4:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }))();\n      return function () {\n        current.removeEventListener('pointerover', handlePointerOver);\n        current.removeEventListener('scroll', handleScroll);\n      };\n    });\n  }, [callbackRefWithSubscribe, observer]);\n}","map":{"version":3,"sources":["../../../src/hooks/internal/useObserveScrollLeft.js"],"names":["setTimeout","resolve","memoizedEmitValue","observer","initial","fraction","width","emitValue","offsetWidth","scrollLeft","scrollWidth","current","handleScroll","handlePointerOver","passive","sleepZero"],"mappings":"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","sourcesContent":["import { useEffect } from 'react';\nimport memoize from 'memoize-one';\n\nimport debounce from '../../util/debounce';\n\nfunction sleepZero() {\n  return new Promise(resolve => setTimeout(() => resolve()));\n}\n\nexport default function useObserveScrollLeft(callbackRefWithSubscribe, observer) {\n  useEffect(\n    () =>\n      callbackRefWithSubscribe.subscribe(current => {\n        if (!current) {\n          return;\n        }\n\n        const memoizedEmitValue = memoize(\n          (initial, fraction, width) => observer && observer({ initial, fraction, width })\n        );\n\n        const emitValue = initial => {\n          const { offsetWidth, scrollLeft, scrollWidth } = current;\n\n          memoizedEmitValue(\n            initial,\n            `${scrollWidth === offsetWidth ? 0 : (scrollLeft / (scrollWidth - offsetWidth)) * 100}%`,\n            `${(offsetWidth / scrollWidth) * 100}%`\n          );\n        };\n\n        const handleScroll = () => emitValue(false);\n\n        const handlePointerOver = debounce(() => {\n          // We need to send \"onScroll\" because \"scrollWidth\" might have changed\n          // For example, the container resized, the scroll width will be incorrect\n          // We will debounce to prevent \"pointerOver\" calculating too often\n          // We will memoize to prevent firing unnecessary \"onScroll\"\n          emitValue(false);\n        });\n\n        current.addEventListener('pointerover', handlePointerOver, { passive: true });\n        current.addEventListener('scroll', handleScroll, { passive: true });\n\n        (async function () {\n          if (current.scrollWidth === current.offsetWidth) {\n            // HACK: Chrome 66 will initially say scrollWidth equals to offsetWidth, until some time later\n            await sleepZero();\n          }\n\n          emitValue(true);\n        })();\n\n        return () => {\n          current.removeEventListener('pointerover', handlePointerOver);\n          current.removeEventListener('scroll', handleScroll);\n        };\n      }),\n    [callbackRefWithSubscribe, observer]\n  );\n}\n"]},"metadata":{},"sourceType":"script"}